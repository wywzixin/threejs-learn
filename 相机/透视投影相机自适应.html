<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <script src="../../three.js-r129/build/three.js"></script>
        <script src="../../three.js-r129/examples/js/controls/OrbitControls.js"></script>
    </head>
    <body>
        <script>
            /**
             * 创建场景对象Scene
             */
            let scene = new THREE.Scene();
            /**
             * 创建网格模型
             */
            //创建一个立方体几何对象Geometry
            let geometry = new THREE.BoxGeometry(100, 100, 100);
            console.log(geometry);
            console.log('几何体顶点位置数据', geometry.attributes.position);
            console.log('三角面数据', geometry.normal);
            // 材质对象
            let material = new THREE.MeshLambertMaterial({
                color: 0x0000ff, // 三角面颜色
                // wireframe:true,//线框模式渲染
            });
            // 网格模型对象Mesh
            let mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            let axesHelper = new THREE.AxesHelper(250);
            scene.add(axesHelper);

            /**
             *
             * 光源设置
             */
            // 点光源
            let point = new THREE.PointLight(0xffffff);
            point.position.set(400, 200, 300); // 点光源位置
            scene.add(point);

            //环境光
            let ambient = new THREE.AmbientLight(0x444444);
            scene.add(ambient);
            /**
             *
             * 透视投影相机设置
             */
            let width = window.innerWidth; // 窗口宽度
            let height = window.innerHeight; // 窗口高度

            // 透视投影相机对象
            let camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
            camera.position.set(200, 300, 200); // 设置相机位置
            console.log(scene.position);
            camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
            let helper = new THREE.CameraHelper(camera);
            scene.add(helper);
            /**
             * 创建渲染器对象
             */
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height); // 设置渲染区域的尺寸
            renderer.setClearColor(0xb9d3ff, 1); // 设置背景颜色
            document.body.appendChild(renderer.domElement); // body元素插入canvas对象

            // 渲染吗函数执行渲染操作
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.update();
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            // onresize 事件会在窗口被调整大小时发生
            window.onresize = function () {
                // 重置渲染器输出画布canvas尺寸
                renderer.setSize(window.innerWidth, window.innerHeight);
                // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比
                camera.aspect = window.innerWidth / window.innerHeight;
                // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix
                // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)
                // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵
                camera.updateProjectionMatrix();
            };
        </script>
    </body>
</html>
